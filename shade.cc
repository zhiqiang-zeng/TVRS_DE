/*
  SHADE implemented by C++ for Special Session & Competition on Real-Parameter Single Objective Optimization at CEC-2013
  
  Version: 1.0   Date: 28/June/2013
  Written by Ryoji Tanabe (rt.ryoji.tanabe@gmail.com)
*/

#include"de.h"
#include <iostream>
#include<string>
#include <fstream>
#include< sstream>


Fitness SHADE::run() {
 cout << setprecision(16);
 initializeParameters();
 setSHADEParameters();

 //population
  vector <Individual> pop;
  //fitness value of the population
  vector <Fitness> fitness(pop_size, 0);

  vector <Individual> children;
  vector <Fitness> children_fitness(pop_size, 0);

  vector <int> stop_count(pop_size, 0);
  vector <int> used_flag(pop_size, 0);
  //initialize population
  for (int i = 0; i < pop_size; i++) {
    pop.push_back(makeNewIndividual());
    children.push_back((variable*)malloc(sizeof(variable) * problem_size));
  }

  // evaluate the initial population's fitness values
  evaluatePopulation(pop, fitness);
  //number of fitness evaluations is initialized
  int nfe = pop_size;

  //best-so-far solution
  Individual bsf_solution = (variable*)malloc(sizeof(variable) * problem_size);
  //fitness value of the best-so-far solution
  Fitness bsf_fitness;
  //initialize the best-so-far solution and its fitness value
  setBestSolution(pop, fitness, bsf_solution, bsf_fitness);
  
  //  cout << bsf_fitness - optimum << endl;

  //SHADE parameters
  
 
 
 

  //index counter
  int memory_pos = 0;

  int random_selected_period;
 
 
  

  variable temp_sum_sf;
  variable sum_dif_fitness;
  variable weight;

  // for current-to-pbest/1
  int p_best_ind;
  int p_num;
 
  //main loop
  while (nfe < max_num_evaluations) {
    
   
    for (int target = 0; target < pop_size; target++) {
      //In each generation, CR_i and F_i used by each individual x_i are generated by first selecting an index r_i randomly from [1, H] 

      vector<int> less_index;

      for (int k = 0; k < pop_size; k++)
      {
          if (stop_count[k] <= stop_num)less_index.push_back(k);
      }
      //operateCurrentToPBest1BinWithArchive(pop, &children[target][0], target, p_best_ind, pop_sf[target], pop_cr[target], archive, arc_ind_count);
      operateCurrentToPBest1BinWithArchive(pop, &children[target][0], target, stop_count[target],used_flag, less_index);
      less_index.clear();
     
    }

    // evaluate the children's fitness values
    evaluatePopulation(children, children_fitness);
    
    /////////////////////////////////////////////////////////////////////////
    //update the bsf-solution and check the current number of fitness evaluations
    // if the current number of fitness evaluations over the max number of fitness evaluations, the search is terminated
    // So, this program is unconcerned about SHADE algorithm directly
    for (int i = 0; i < pop_size; i++) {
      nfe++;

      //following the rules of CEC 2013 real parameter competition, 
      //if the gap between the error values of the best solution found and the optimal solution was 10^{âˆ’8} or smaller,
      //the error was treated as 0
      if ((children_fitness[i] - optimum) < epsilon) {
	children_fitness[i] = optimum;
      }

      if (children_fitness[i] < bsf_fitness) {
  	bsf_fitness = children_fitness[i];
  	for (int j = 0; j < problem_size; j ++) {
  	  bsf_solution[j] = children[i][j];
  	}
      }
 
      // if (nfe % 1000 == 0) {
      // 	//output the error value
      // 	cout << bsf_fitness - optimum << endl; 
      // }

      if (nfe % (g_problem_size * 100) == 0) {
          if (nfe == (int)(0.01 * max_num_evaluations)) outFile << bsf_fitness - optimum << " ";
          else if (nfe == (int)(0.02 * max_num_evaluations)) outFile << bsf_fitness - optimum << " ";
          else if (nfe == (int)(0.03 * max_num_evaluations)) outFile << bsf_fitness - optimum << " ";
          else if (nfe == (int)(0.05 * max_num_evaluations)) outFile << bsf_fitness - optimum << " ";
          else if (nfe == (int)(0.1 * max_num_evaluations)) outFile << bsf_fitness - optimum << " ";
          else if (nfe == (int)(0.2 * max_num_evaluations)) outFile << bsf_fitness - optimum << " ";
          else if (nfe == (int)(0.3 * max_num_evaluations)) outFile << bsf_fitness - optimum << " ";
          else if (nfe == (int)(0.4 * max_num_evaluations)) outFile << bsf_fitness - optimum << " ";
          else if (nfe == (int)(0.5 * max_num_evaluations)) outFile << bsf_fitness - optimum << " ";
          else if (nfe == (int)(0.6 * max_num_evaluations)) outFile << bsf_fitness - optimum << " ";
          else if (nfe == (int)(0.7 * max_num_evaluations)) outFile << bsf_fitness - optimum << " ";
          else if (nfe == (int)(0.8 * max_num_evaluations)) outFile << bsf_fitness - optimum << " ";
          else if (nfe == (int)(0.9 * max_num_evaluations)) outFile << bsf_fitness - optimum << " ";
          else if (nfe == (int)(1.0 * max_num_evaluations)) outFile << bsf_fitness - optimum << endl;
      }

    

      if (nfe >= max_num_evaluations) {
  	break;
      }
    }
    ////////////////////////////////////////////////////////////////////////////

   

    //generation alternation
    for (int i = 0; i < pop_size; i++) {
     
      if (children_fitness[i] <= fitness[i])
      {
          fitness[i] = children_fitness[i];
          stop_count[i] = 0;
          for (int j = 0; j < problem_size; j++) {
              pop[i][j] = children[i][j];
          }
      }
      else 
      {
          stop_count[i] = stop_count[i] + 1;
      }

    }
  
  
  }
  stop_count.clear();
  used_flag.clear();


  pop.clear();
 
  fitness.clear();

  children.clear();
  children_fitness.clear();

  return bsf_fitness - optimum;
}

void SHADE::operateCurrentToPBest1BinWithArchive(const vector<Individual> &pop, Individual child, int &target,int t_stop, vector<int>& used_flag, vector<int> &less_index) {
  int r1, r2,r3;
  double scaling_factor = 0.7;
  double cross_rate = 0.5;
  do {
    r1 = rand() % pop_size;
  } while (r1 == target);
  do {
    r2 = rand() % (pop_size);
  } while ((r2 == target) || (r2 == r1));
  do {
      r3 = rand() % (pop_size);
  } while ((r3 == target) || (r3 == r2) || (r3 == r1));

  int random_variable = rand() % problem_size;
  



      if (t_stop > stop_num)
      {
          if (used_flag[target] == 0)
          {
              for (int i = 0; i < problem_size; i++) {
                  if ((randDouble() < cross_rate) || (i == random_variable)) {
                      child[i] = pop[r1][i] +  scaling_factor * (pop[r2][i] - pop[r3][i]);
                  }
                  else {
                      child[i] = pop[target][i];
                  }
              }
              //modifySolutionWithParentMedium(child, pop[target]);
              used_flag[target] = 1;
          }
          else
          {

              if (less_index.size() > 0)
              {
                  int new_target;

                  new_target = rand() % less_index.size();



                  for (int i = 0; i < problem_size; i++) {
                      if ((randDouble() < cross_rate) || (i == random_variable)) {
                          child[i] = pop[r1][i] + scaling_factor * (pop[r2][i] - pop[r3][i]);
                      }
                      else {
                          child[i] = pop[less_index[new_target]][i];
                      }
                  }
                  used_flag[target] = 0;
                  //modifySolutionWithParentMedium(child, pop[less_index[new_target]]);
              }
              else
              {
                  for (int i = 0; i < problem_size; i++) {
                      if ((randDouble() < cross_rate) || (i == random_variable)) {
                          child[i] = pop[r1][i]  + scaling_factor * (pop[r2][i] - pop[r3][i]);
                      }
                      else {
                          child[i] = pop[target][i];
                      }
                  }
                  //modifySolutionWithParentMedium(child, pop[target]);
                  used_flag[target] = 1;
              }
          }
      }
      else
      {
          for (int i = 0; i < problem_size; i++) {
              if ((randDouble() < cross_rate) || (i == random_variable)) {
                  child[i] = pop[r1][i]  + scaling_factor * (pop[r2][i] - pop[r3][i]);
              }
              else {
                  child[i] = pop[target][i];
              }
          }
          //modifySolutionWithParentMedium(child, pop[target]);
      }


 //   for (int i = 0; i < problem_size; i++) {
 //     if ((randDouble() < cross_rate) || (i == random_variable)) {
	//child[i] = pop[target][i] + scaling_factor * (pop[p_best_individual][i] - pop[target][i]) + scaling_factor * (pop[r1][i] - pop[r2][i]);
 //     }
 //     else {
	//child[i] = pop[target][i];
 //     }
 //   }



  

  //If the mutant vector violates bounds, the bound handling method is applied
  modifySolutionWithParentMedium(child,  pop[target]);
}

void  SHADE::setSHADEParameters() {
  arc_size = g_arc_size;
  memory_size = g_memory_size;
}

